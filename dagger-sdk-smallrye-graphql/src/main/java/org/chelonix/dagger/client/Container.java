// This class has been generated by dagger-java-sdk. DO NOT EDIT.
package org.chelonix.dagger.client;

import java.lang.Boolean;
import java.lang.Integer;
import java.lang.InterruptedException;
import java.lang.String;
import java.util.List;
import java.util.concurrent.ExecutionException;

/**
 * An OCI-compatible container, also known as a docker container.
 */
public class Container implements IdProvider<ContainerID> {
  private QueryContext queryContext;

  private String endpoint;

  private String envVariable;

  private Integer exitCode;

  private Boolean export;

  private String hostname;

  private ContainerID id;

  private String imageRef;

  private String label;

  private Platform platform;

  private String publish;

  private String stderr;

  private String stdout;

  private ContainerID sync;

  private String user;

  private String workdir;

  /**
   * Empty constructor for JSON-B deserialization
   */
  protected Container() {
  }

  Container(QueryContext queryContext) {
    this.queryContext = queryContext;
  }

  /**
   * <p>Initializes this container from a Dockerfile build.</p>
   * @param context Directory context used by the Dockerfile.
   */
  public Container build(Directory context, BuildArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("context", context);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("build", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Initializes this container from a Dockerfile build.</p>
   * @param context Directory context used by the Dockerfile.
   */
  public Container build(Directory context) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("context", context);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("build", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves default arguments for future commands.</p>
   */
  public List<String> defaultArgs() throws InterruptedException, ExecutionException,
      DaggerQueryException {
    QueryContext ctx = this.queryContext.chain("defaultArgs");
    return ctx.executeListQuery(String.class);
  }

  /**
   * <p>Retrieves a directory at the given path.<br/><br/>Mounts are included.</p>
   * @param path The path of the directory to retrieve (e.g., "./src").
   */
  public Directory directory(String path) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("directory", fieldArgs);
    return new Directory(ctx);
  }

  /**
   * <p>Retrieves an endpoint that clients can use to reach this container.<br/><br/>If no port is specified, the first exposed port is used. If none exist an error is returned.<br/><br/>If a scheme is specified, a URL is returned. Otherwise, a host:port pair is returned.<br/><br/>Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.</p>
   */
  public String endpoint(EndpointArguments optArgs) throws InterruptedException, ExecutionException,
      DaggerQueryException {
    if (this.endpoint != null) {
      return endpoint;
    }
    Arguments.Builder builder = Arguments.newBuilder();
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("endpoint", fieldArgs);
    return ctx.executeQuery(String.class);
  }

  /**
   * <p>Retrieves an endpoint that clients can use to reach this container.<br/><br/>If no port is specified, the first exposed port is used. If none exist an error is returned.<br/><br/>If a scheme is specified, a URL is returned. Otherwise, a host:port pair is returned.<br/><br/>Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.</p>
   */
  public String endpoint() throws InterruptedException, ExecutionException, DaggerQueryException {
    if (this.endpoint != null) {
      return endpoint;
    }
    Arguments.Builder builder = Arguments.newBuilder();
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("endpoint", fieldArgs);
    return ctx.executeQuery(String.class);
  }

  /**
   * <p>Retrieves entrypoint to be prepended to the arguments of all commands.</p>
   */
  public List<String> entrypoint() throws InterruptedException, ExecutionException,
      DaggerQueryException {
    QueryContext ctx = this.queryContext.chain("entrypoint");
    return ctx.executeListQuery(String.class);
  }

  /**
   * <p>Retrieves the value of the specified environment variable.</p>
   * @param name The name of the environment variable to retrieve (e.g., "PATH").
   */
  public String envVariable(String name) throws InterruptedException, ExecutionException,
      DaggerQueryException {
    if (this.envVariable != null) {
      return envVariable;
    }
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("name", name);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("envVariable", fieldArgs);
    return ctx.executeQuery(String.class);
  }

  /**
   * <p>Retrieves the list of environment variables passed to commands.</p>
   */
  public List<EnvVariable> envVariables() throws InterruptedException, ExecutionException,
      DaggerQueryException {
    QueryContext ctx = this.queryContext.chain("envVariables");
    ctx = ctx.chain(List.of("name","value"));
    return ctx.executeListQuery(EnvVariable.class);
  }

  /**
   * <p>Retrieves this container after executing the specified command inside it.</p>
   */
  public Container exec(ExecArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("exec", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container after executing the specified command inside it.</p>
   */
  public Container exec() {
    Arguments.Builder builder = Arguments.newBuilder();
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("exec", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Exit code of the last executed command. Zero means success.<br/><br/>Will execute default command if none is set, or error if there's no default.</p>
   */
  public Integer exitCode() throws InterruptedException, ExecutionException, DaggerQueryException {
    if (this.exitCode != null) {
      return exitCode;
    }
    QueryContext ctx = this.queryContext.chain("exitCode");
    return ctx.executeQuery(Integer.class);
  }

  /**
   * <p>Writes the container as an OCI tarball to the destination file path on the host for the specified platform variants.<br/><br/>Return true on success.<br/>It can also publishes platform variants.</p>
   * @param path Host's destination path (e.g., "./tarball").<br/>Path can be relative to the engine's workdir or absolute.
   */
  public Boolean export(String path, ExportArguments optArgs) throws InterruptedException,
      ExecutionException, DaggerQueryException {
    if (this.export != null) {
      return export;
    }
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("export", fieldArgs);
    return ctx.executeQuery(Boolean.class);
  }

  /**
   * <p>Writes the container as an OCI tarball to the destination file path on the host for the specified platform variants.<br/><br/>Return true on success.<br/>It can also publishes platform variants.</p>
   * @param path Host's destination path (e.g., "./tarball").<br/>Path can be relative to the engine's workdir or absolute.
   */
  public Boolean export(String path) throws InterruptedException, ExecutionException,
      DaggerQueryException {
    if (this.export != null) {
      return export;
    }
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("export", fieldArgs);
    return ctx.executeQuery(Boolean.class);
  }

  /**
   * <p>Retrieves the list of exposed ports.<br/><br/>Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.</p>
   */
  public List<Port> exposedPorts() throws InterruptedException, ExecutionException,
      DaggerQueryException {
    QueryContext ctx = this.queryContext.chain("exposedPorts");
    ctx = ctx.chain(List.of("description","port","protocol"));
    return ctx.executeListQuery(Port.class);
  }

  /**
   * <p>Retrieves a file at the given path.<br/><br/>Mounts are included.</p>
   * @param path The path of the file to retrieve (e.g., "./README.md").
   */
  public File file(String path) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("file", fieldArgs);
    return new File(ctx);
  }

  /**
   * <p>Initializes this container from a pulled base image.</p>
   * @param address Image's address from its registry.<br/><br/>Formatted as [host]/[user]/[repo]:[tag] (e.g., "docker.io/dagger/dagger:main").
   */
  public Container from(String address) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("address", address);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("from", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container's root filesystem. Mounts are not included.</p>
   */
  public Directory fs() {
    QueryContext ctx = this.queryContext.chain("fs");
    return new Directory(ctx);
  }

  /**
   * <p>Retrieves a hostname which can be used by clients to reach this container.<br/><br/>Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.</p>
   */
  public String hostname() throws InterruptedException, ExecutionException, DaggerQueryException {
    if (this.hostname != null) {
      return hostname;
    }
    QueryContext ctx = this.queryContext.chain("hostname");
    return ctx.executeQuery(String.class);
  }

  /**
   * <p>A unique identifier for this container.</p>
   */
  public ContainerID id() throws InterruptedException, ExecutionException, DaggerQueryException {
    if (this.id != null) {
      return id;
    }
    QueryContext ctx = this.queryContext.chain("id");
    return ctx.executeQuery(ContainerID.class);
  }

  /**
   * <p>The unique image reference which can only be retrieved immediately after the 'Container.From' call.</p>
   */
  public String imageRef() throws InterruptedException, ExecutionException, DaggerQueryException {
    if (this.imageRef != null) {
      return imageRef;
    }
    QueryContext ctx = this.queryContext.chain("imageRef");
    return ctx.executeQuery(String.class);
  }

  /**
   * <p>Reads the container from an OCI tarball.<br/><br/>NOTE: this involves unpacking the tarball to an OCI store on the host at<br/>$XDG_CACHE_DIR/dagger/oci. This directory can be removed whenever you like.</p>
   * @param source File to read the container from.
   */
  public Container importTarball(File source, ImportArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("source", source);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("import", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Reads the container from an OCI tarball.<br/><br/>NOTE: this involves unpacking the tarball to an OCI store on the host at<br/>$XDG_CACHE_DIR/dagger/oci. This directory can be removed whenever you like.</p>
   * @param source File to read the container from.
   */
  public Container importTarball(File source) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("source", source);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("import", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves the value of the specified label.</p>
   * @param name 
   */
  public String label(String name) throws InterruptedException, ExecutionException,
      DaggerQueryException {
    if (this.label != null) {
      return label;
    }
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("name", name);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("label", fieldArgs);
    return ctx.executeQuery(String.class);
  }

  /**
   * <p>Retrieves the list of labels passed to container.</p>
   */
  public List<Label> labels() throws InterruptedException, ExecutionException,
      DaggerQueryException {
    QueryContext ctx = this.queryContext.chain("labels");
    ctx = ctx.chain(List.of("name","value"));
    return ctx.executeListQuery(Label.class);
  }

  /**
   * <p>Retrieves the list of paths where a directory is mounted.</p>
   */
  public List<String> mounts() throws InterruptedException, ExecutionException,
      DaggerQueryException {
    QueryContext ctx = this.queryContext.chain("mounts");
    return ctx.executeListQuery(String.class);
  }

  /**
   * <p>Creates a named sub-pipeline</p>
   * @param name Pipeline name.
   */
  public Container pipeline(String name, PipelineArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("name", name);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("pipeline", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Creates a named sub-pipeline</p>
   * @param name Pipeline name.
   */
  public Container pipeline(String name) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("name", name);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("pipeline", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>The platform this container executes and publishes as.</p>
   */
  public Platform platform() throws InterruptedException, ExecutionException, DaggerQueryException {
    if (this.platform != null) {
      return platform;
    }
    QueryContext ctx = this.queryContext.chain("platform");
    return ctx.executeQuery(Platform.class);
  }

  /**
   * <p>Publishes this container as a new image to the specified address.<br/><br/>Publish returns a fully qualified ref.<br/>It can also publish platform variants.</p>
   * @param address Registry's address to publish the image to.<br/><br/>Formatted as [host]/[user]/[repo]:[tag] (e.g. "docker.io/dagger/dagger:main").
   */
  public String publish(String address, PublishArguments optArgs) throws InterruptedException,
      ExecutionException, DaggerQueryException {
    if (this.publish != null) {
      return publish;
    }
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("address", address);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("publish", fieldArgs);
    return ctx.executeQuery(String.class);
  }

  /**
   * <p>Publishes this container as a new image to the specified address.<br/><br/>Publish returns a fully qualified ref.<br/>It can also publish platform variants.</p>
   * @param address Registry's address to publish the image to.<br/><br/>Formatted as [host]/[user]/[repo]:[tag] (e.g. "docker.io/dagger/dagger:main").
   */
  public String publish(String address) throws InterruptedException, ExecutionException,
      DaggerQueryException {
    if (this.publish != null) {
      return publish;
    }
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("address", address);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("publish", fieldArgs);
    return ctx.executeQuery(String.class);
  }

  /**
   * <p>Retrieves this container's root filesystem. Mounts are not included.</p>
   */
  public Directory rootfs() {
    QueryContext ctx = this.queryContext.chain("rootfs");
    return new Directory(ctx);
  }

  /**
   * <p>The error stream of the last executed command.<br/><br/>Will execute default command if none is set, or error if there's no default.</p>
   */
  public String stderr() throws InterruptedException, ExecutionException, DaggerQueryException {
    if (this.stderr != null) {
      return stderr;
    }
    QueryContext ctx = this.queryContext.chain("stderr");
    return ctx.executeQuery(String.class);
  }

  /**
   * <p>The output stream of the last executed command.<br/><br/>Will execute default command if none is set, or error if there's no default.</p>
   */
  public String stdout() throws InterruptedException, ExecutionException, DaggerQueryException {
    if (this.stdout != null) {
      return stdout;
    }
    QueryContext ctx = this.queryContext.chain("stdout");
    return ctx.executeQuery(String.class);
  }

  /**
   * <p>Forces evaluation of the pipeline in the engine.<br/><br/>It doesn't run the default command if no exec has been set.</p>
   */
  public Container sync() throws InterruptedException, ExecutionException, DaggerQueryException {
    QueryContext ctx = this.queryContext.chain("sync");
    ctx.executeQuery();
    return this;
  }

  /**
   * <p>Retrieves the user to be set for all commands.</p>
   */
  public String user() throws InterruptedException, ExecutionException, DaggerQueryException {
    if (this.user != null) {
      return user;
    }
    QueryContext ctx = this.queryContext.chain("user");
    return ctx.executeQuery(String.class);
  }

  /**
   * <p>Configures default arguments for future commands.</p>
   */
  public Container withDefaultArgs(WithDefaultArgsArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("withDefaultArgs", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Configures default arguments for future commands.</p>
   */
  public Container withDefaultArgs() {
    Arguments.Builder builder = Arguments.newBuilder();
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withDefaultArgs", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a directory written at the given path.</p>
   * @param path Location of the written directory (e.g., "/tmp/directory").
   * @param directory Identifier of the directory to write
   */
  public Container withDirectory(String path, Directory directory, WithDirectoryArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("directory", directory);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("withDirectory", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a directory written at the given path.</p>
   * @param path Location of the written directory (e.g., "/tmp/directory").
   * @param directory Identifier of the directory to write
   */
  public Container withDirectory(String path, Directory directory) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("directory", directory);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withDirectory", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container but with a different command entrypoint.</p>
   * @param args Entrypoint to use for future executions (e.g., ["go", "run"]).
   */
  public Container withEntrypoint(List<String> args) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("args", args);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withEntrypoint", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus the given environment variable.</p>
   * @param name The name of the environment variable (e.g., "HOST").
   * @param value The value of the environment variable. (e.g., "localhost").
   */
  public Container withEnvVariable(String name, String value) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("name", name);
    builder.add("value", value);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withEnvVariable", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container after executing the specified command inside it.</p>
   * @param args Command to run instead of the container's default command (e.g., ["run", "main.go"]).<br/><br/>If empty, the container's default command is used.
   */
  public Container withExec(List<String> args, WithExecArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("args", args);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("withExec", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container after executing the specified command inside it.</p>
   * @param args Command to run instead of the container's default command (e.g., ["run", "main.go"]).<br/><br/>If empty, the container's default command is used.
   */
  public Container withExec(List<String> args) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("args", args);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withExec", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Expose a network port.<br/><br/>Exposed ports serve two purposes:<br/>  - For health checks and introspection, when running services<br/>  - For setting the EXPOSE OCI field when publishing the container<br/><br/>Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.</p>
   * @param port Port number to expose
   */
  public Container withExposedPort(Integer port, WithExposedPortArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("port", port);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("withExposedPort", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Expose a network port.<br/><br/>Exposed ports serve two purposes:<br/>  - For health checks and introspection, when running services<br/>  - For setting the EXPOSE OCI field when publishing the container<br/><br/>Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.</p>
   * @param port Port number to expose
   */
  public Container withExposedPort(Integer port) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("port", port);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withExposedPort", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Initializes this container from this DirectoryID.</p>
   * @param id 
   */
  public Container withFS(Directory id) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("id", id);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withFS", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus the contents of the given file copied to the given path.</p>
   * @param path Location of the copied file (e.g., "/tmp/file.txt").
   * @param source Identifier of the file to copy.
   */
  public Container withFile(String path, File source, WithFileArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("source", source);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("withFile", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus the contents of the given file copied to the given path.</p>
   * @param path Location of the copied file (e.g., "/tmp/file.txt").
   * @param source Identifier of the file to copy.
   */
  public Container withFile(String path, File source) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("source", source);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withFile", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus the given label.</p>
   * @param name The name of the label (e.g., "org.opencontainers.artifact.created").
   * @param value The value of the label (e.g., "2023-01-01T00:00:00Z").
   */
  public Container withLabel(String name, String value) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("name", name);
    builder.add("value", value);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withLabel", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a cache volume mounted at the given path.</p>
   * @param path Location of the cache directory (e.g., "/cache/node_modules").
   * @param cache Identifier of the cache volume to mount.
   */
  public Container withMountedCache(String path, CacheVolume cache,
      WithMountedCacheArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("cache", cache);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("withMountedCache", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a cache volume mounted at the given path.</p>
   * @param path Location of the cache directory (e.g., "/cache/node_modules").
   * @param cache Identifier of the cache volume to mount.
   */
  public Container withMountedCache(String path, CacheVolume cache) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("cache", cache);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withMountedCache", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a directory mounted at the given path.</p>
   * @param path Location of the mounted directory (e.g., "/mnt/directory").
   * @param source Identifier of the mounted directory.
   */
  public Container withMountedDirectory(String path, Directory source,
      WithMountedDirectoryArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("source", source);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("withMountedDirectory", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a directory mounted at the given path.</p>
   * @param path Location of the mounted directory (e.g., "/mnt/directory").
   * @param source Identifier of the mounted directory.
   */
  public Container withMountedDirectory(String path, Directory source) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("source", source);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withMountedDirectory", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a file mounted at the given path.</p>
   * @param path Location of the mounted file (e.g., "/tmp/file.txt").
   * @param source Identifier of the mounted file.
   */
  public Container withMountedFile(String path, File source, WithMountedFileArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("source", source);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("withMountedFile", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a file mounted at the given path.</p>
   * @param path Location of the mounted file (e.g., "/tmp/file.txt").
   * @param source Identifier of the mounted file.
   */
  public Container withMountedFile(String path, File source) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("source", source);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withMountedFile", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a secret mounted into a file at the given path.</p>
   * @param path Location of the secret file (e.g., "/tmp/secret.txt").
   * @param source Identifier of the secret to mount.
   */
  public Container withMountedSecret(String path, Secret source,
      WithMountedSecretArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("source", source);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("withMountedSecret", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a secret mounted into a file at the given path.</p>
   * @param path Location of the secret file (e.g., "/tmp/secret.txt").
   * @param source Identifier of the secret to mount.
   */
  public Container withMountedSecret(String path, Secret source) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("source", source);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withMountedSecret", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a temporary directory mounted at the given path.</p>
   * @param path Location of the temporary directory (e.g., "/tmp/temp_dir").
   */
  public Container withMountedTemp(String path) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withMountedTemp", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a new file written at the given path.</p>
   * @param path Location of the written file (e.g., "/tmp/file.txt").
   */
  public Container withNewFile(String path, WithNewFileArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("withNewFile", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a new file written at the given path.</p>
   * @param path Location of the written file (e.g., "/tmp/file.txt").
   */
  public Container withNewFile(String path) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withNewFile", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container with a registry authentication for a given address.</p>
   * @param address Registry's address to bind the authentication to.<br/>Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
   * @param username The username of the registry's account (e.g., "Dagger").
   * @param secret The API key, password or token to authenticate to this registry.
   */
  public Container withRegistryAuth(String address, String username, Secret secret) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("address", address);
    builder.add("username", username);
    builder.add("secret", secret);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withRegistryAuth", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Initializes this container from this DirectoryID.</p>
   * @param id 
   */
  public Container withRootfs(Directory id) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("id", id);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withRootfs", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus an env variable containing the given secret.</p>
   * @param name The name of the secret variable (e.g., "API_SECRET").
   * @param secret The identifier of the secret value.
   */
  public Container withSecretVariable(String name, Secret secret) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("name", name);
    builder.add("secret", secret);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withSecretVariable", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Establish a runtime dependency on a service.<br/><br/>The service will be started automatically when needed and detached when it is<br/>no longer needed, executing the default command if none is set.<br/><br/>The service will be reachable from the container via the provided hostname alias.<br/><br/>The service dependency will also convey to any files or directories produced by the container.<br/><br/>Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.</p>
   * @param alias A name that can be used to reach the service from the container
   * @param service Identifier of the service container
   */
  public Container withServiceBinding(String alias, Container service) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("alias", alias);
    builder.add("service", service);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withServiceBinding", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a socket forwarded to the given Unix socket path.</p>
   * @param path Location of the forwarded Unix socket (e.g., "/tmp/socket").
   * @param source Identifier of the socket to forward.
   */
  public Container withUnixSocket(String path, Socket source, WithUnixSocketArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("source", source);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("withUnixSocket", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container plus a socket forwarded to the given Unix socket path.</p>
   * @param path Location of the forwarded Unix socket (e.g., "/tmp/socket").
   * @param source Identifier of the socket to forward.
   */
  public Container withUnixSocket(String path, Socket source) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    builder.add("source", source);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withUnixSocket", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container with a different command user.</p>
   * @param name The user to set (e.g., "root").
   */
  public Container withUser(String name) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("name", name);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withUser", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container with a different working directory.</p>
   * @param path The path to set as the working directory (e.g., "/app").
   */
  public Container withWorkdir(String path) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withWorkdir", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container minus the given environment variable.</p>
   * @param name The name of the environment variable (e.g., "HOST").
   */
  public Container withoutEnvVariable(String name) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("name", name);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withoutEnvVariable", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Unexpose a previously exposed port.<br/><br/>Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.</p>
   * @param port Port number to unexpose
   */
  public Container withoutExposedPort(Integer port, WithoutExposedPortArguments optArgs) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("port", port);
    Arguments fieldArgs = builder.build();
    fieldArgs = fieldArgs.merge(optArgs.toArguments());
    QueryContext ctx = this.queryContext.chain("withoutExposedPort", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Unexpose a previously exposed port.<br/><br/>Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.</p>
   * @param port Port number to unexpose
   */
  public Container withoutExposedPort(Integer port) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("port", port);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withoutExposedPort", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container minus the given environment label.</p>
   * @param name The name of the label to remove (e.g., "org.opencontainers.artifact.created").
   */
  public Container withoutLabel(String name) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("name", name);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withoutLabel", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container after unmounting everything at the given path.</p>
   * @param path Location of the cache directory (e.g., "/cache/node_modules").
   */
  public Container withoutMount(String path) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withoutMount", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container without the registry authentication of a given address.</p>
   * @param address Registry's address to remove the authentication from.<br/>Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
   */
  public Container withoutRegistryAuth(String address) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("address", address);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withoutRegistryAuth", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves this container with a previously added Unix socket removed.</p>
   * @param path Location of the socket to remove (e.g., "/tmp/socket").
   */
  public Container withoutUnixSocket(String path) {
    Arguments.Builder builder = Arguments.newBuilder();
    builder.add("path", path);
    Arguments fieldArgs = builder.build();
    QueryContext ctx = this.queryContext.chain("withoutUnixSocket", fieldArgs);
    return new Container(ctx);
  }

  /**
   * <p>Retrieves the working directory for all commands.</p>
   */
  public String workdir() throws InterruptedException, ExecutionException, DaggerQueryException {
    if (this.workdir != null) {
      return workdir;
    }
    QueryContext ctx = this.queryContext.chain("workdir");
    return ctx.executeQuery(String.class);
  }

  public static class BuildArguments {
    String dockerfile;

    List<BuildArg> buildArgs;

    String target;

    List<Secret> secrets;

    private BuildArguments() {
    }

    static BuildArgumentsBuilder newBuilder() {
      BuildArguments args = new BuildArguments();
      return new BuildArgumentsBuilder(args);
    }

    public String getDockerfile() {
      return this.dockerfile;
    }

    public List<BuildArg> getBuildArgs() {
      return this.buildArgs;
    }

    public String getTarget() {
      return this.target;
    }

    public List<Secret> getSecrets() {
      return this.secrets;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("dockerfile", this.dockerfile);
      builder.add("buildArgs", this.buildArgs);
      builder.add("target", this.target);
      builder.add("secrets", this.secrets);
          return builder.build();
    }
  }

  public static class BuildArgumentsBuilder {
    private BuildArguments arguments;

    BuildArgumentsBuilder(BuildArguments arguments) {
      this.arguments = arguments;
    }

    public BuildArgumentsBuilder withDockerfile(String dockerfile) {
      this.arguments.dockerfile = dockerfile;
      return this;
    }

    public BuildArgumentsBuilder withBuildArgs(List<BuildArg> buildArgs) {
      this.arguments.buildArgs = buildArgs;
      return this;
    }

    public BuildArgumentsBuilder withTarget(String target) {
      this.arguments.target = target;
      return this;
    }

    public BuildArgumentsBuilder withSecrets(List<Secret> secrets) {
      this.arguments.secrets = secrets;
      return this;
    }

    public BuildArguments build() {
      return this.arguments;
    }
  }

  public static class EndpointArguments {
    Integer port;

    String scheme;

    private EndpointArguments() {
    }

    static EndpointArgumentsBuilder newBuilder() {
      EndpointArguments args = new EndpointArguments();
      return new EndpointArgumentsBuilder(args);
    }

    public Integer getPort() {
      return this.port;
    }

    public String getScheme() {
      return this.scheme;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("port", this.port);
      builder.add("scheme", this.scheme);
          return builder.build();
    }
  }

  public static class EndpointArgumentsBuilder {
    private EndpointArguments arguments;

    EndpointArgumentsBuilder(EndpointArguments arguments) {
      this.arguments = arguments;
    }

    public EndpointArgumentsBuilder withPort(Integer port) {
      this.arguments.port = port;
      return this;
    }

    public EndpointArgumentsBuilder withScheme(String scheme) {
      this.arguments.scheme = scheme;
      return this;
    }

    public EndpointArguments build() {
      return this.arguments;
    }
  }

  public static class ExecArguments {
    List<String> args;

    String stdin;

    String redirectStdout;

    String redirectStderr;

    Boolean experimentalPrivilegedNesting;

    private ExecArguments() {
    }

    static ExecArgumentsBuilder newBuilder() {
      ExecArguments args = new ExecArguments();
      return new ExecArgumentsBuilder(args);
    }

    public List<String> getArgs() {
      return this.args;
    }

    public String getStdin() {
      return this.stdin;
    }

    public String getRedirectStdout() {
      return this.redirectStdout;
    }

    public String getRedirectStderr() {
      return this.redirectStderr;
    }

    public Boolean getExperimentalPrivilegedNesting() {
      return this.experimentalPrivilegedNesting;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("args", this.args);
      builder.add("stdin", this.stdin);
      builder.add("redirectStdout", this.redirectStdout);
      builder.add("redirectStderr", this.redirectStderr);
      builder.add("experimentalPrivilegedNesting", this.experimentalPrivilegedNesting);
          return builder.build();
    }
  }

  public static class ExecArgumentsBuilder {
    private ExecArguments arguments;

    ExecArgumentsBuilder(ExecArguments arguments) {
      this.arguments = arguments;
    }

    public ExecArgumentsBuilder withArgs(List<String> args) {
      this.arguments.args = args;
      return this;
    }

    public ExecArgumentsBuilder withStdin(String stdin) {
      this.arguments.stdin = stdin;
      return this;
    }

    public ExecArgumentsBuilder withRedirectStdout(String redirectStdout) {
      this.arguments.redirectStdout = redirectStdout;
      return this;
    }

    public ExecArgumentsBuilder withRedirectStderr(String redirectStderr) {
      this.arguments.redirectStderr = redirectStderr;
      return this;
    }

    public ExecArgumentsBuilder withExperimentalPrivilegedNesting(
        Boolean experimentalPrivilegedNesting) {
      this.arguments.experimentalPrivilegedNesting = experimentalPrivilegedNesting;
      return this;
    }

    public ExecArguments build() {
      return this.arguments;
    }
  }

  public static class ExportArguments {
    List<Container> platformVariants;

    ImageLayerCompression forcedCompression;

    private ExportArguments() {
    }

    static ExportArgumentsBuilder newBuilder() {
      ExportArguments args = new ExportArguments();
      return new ExportArgumentsBuilder(args);
    }

    public List<Container> getPlatformVariants() {
      return this.platformVariants;
    }

    public ImageLayerCompression getForcedCompression() {
      return this.forcedCompression;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("platformVariants", this.platformVariants);
      builder.add("forcedCompression", this.forcedCompression);
          return builder.build();
    }
  }

  public static class ExportArgumentsBuilder {
    private ExportArguments arguments;

    ExportArgumentsBuilder(ExportArguments arguments) {
      this.arguments = arguments;
    }

    public ExportArgumentsBuilder withPlatformVariants(List<Container> platformVariants) {
      this.arguments.platformVariants = platformVariants;
      return this;
    }

    public ExportArgumentsBuilder withForcedCompression(ImageLayerCompression forcedCompression) {
      this.arguments.forcedCompression = forcedCompression;
      return this;
    }

    public ExportArguments build() {
      return this.arguments;
    }
  }

  public static class ImportArguments {
    String tag;

    private ImportArguments() {
    }

    static ImportArgumentsBuilder newBuilder() {
      ImportArguments args = new ImportArguments();
      return new ImportArgumentsBuilder(args);
    }

    public String getTag() {
      return this.tag;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("tag", this.tag);
          return builder.build();
    }
  }

  public static class ImportArgumentsBuilder {
    private ImportArguments arguments;

    ImportArgumentsBuilder(ImportArguments arguments) {
      this.arguments = arguments;
    }

    public ImportArgumentsBuilder withTag(String tag) {
      this.arguments.tag = tag;
      return this;
    }

    public ImportArguments build() {
      return this.arguments;
    }
  }

  public static class PipelineArguments {
    String description;

    List<PipelineLabel> labels;

    private PipelineArguments() {
    }

    static PipelineArgumentsBuilder newBuilder() {
      PipelineArguments args = new PipelineArguments();
      return new PipelineArgumentsBuilder(args);
    }

    public String getDescription() {
      return this.description;
    }

    public List<PipelineLabel> getLabels() {
      return this.labels;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("description", this.description);
      builder.add("labels", this.labels);
          return builder.build();
    }
  }

  public static class PipelineArgumentsBuilder {
    private PipelineArguments arguments;

    PipelineArgumentsBuilder(PipelineArguments arguments) {
      this.arguments = arguments;
    }

    public PipelineArgumentsBuilder withDescription(String description) {
      this.arguments.description = description;
      return this;
    }

    public PipelineArgumentsBuilder withLabels(List<PipelineLabel> labels) {
      this.arguments.labels = labels;
      return this;
    }

    public PipelineArguments build() {
      return this.arguments;
    }
  }

  public static class PublishArguments {
    List<Container> platformVariants;

    ImageLayerCompression forcedCompression;

    private PublishArguments() {
    }

    static PublishArgumentsBuilder newBuilder() {
      PublishArguments args = new PublishArguments();
      return new PublishArgumentsBuilder(args);
    }

    public List<Container> getPlatformVariants() {
      return this.platformVariants;
    }

    public ImageLayerCompression getForcedCompression() {
      return this.forcedCompression;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("platformVariants", this.platformVariants);
      builder.add("forcedCompression", this.forcedCompression);
          return builder.build();
    }
  }

  public static class PublishArgumentsBuilder {
    private PublishArguments arguments;

    PublishArgumentsBuilder(PublishArguments arguments) {
      this.arguments = arguments;
    }

    public PublishArgumentsBuilder withPlatformVariants(List<Container> platformVariants) {
      this.arguments.platformVariants = platformVariants;
      return this;
    }

    public PublishArgumentsBuilder withForcedCompression(ImageLayerCompression forcedCompression) {
      this.arguments.forcedCompression = forcedCompression;
      return this;
    }

    public PublishArguments build() {
      return this.arguments;
    }
  }

  public static class WithDefaultArgsArguments {
    List<String> args;

    private WithDefaultArgsArguments() {
    }

    static WithDefaultArgsArgumentsBuilder newBuilder() {
      WithDefaultArgsArguments args = new WithDefaultArgsArguments();
      return new WithDefaultArgsArgumentsBuilder(args);
    }

    public List<String> getArgs() {
      return this.args;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("args", this.args);
          return builder.build();
    }
  }

  public static class WithDefaultArgsArgumentsBuilder {
    private WithDefaultArgsArguments arguments;

    WithDefaultArgsArgumentsBuilder(WithDefaultArgsArguments arguments) {
      this.arguments = arguments;
    }

    public WithDefaultArgsArgumentsBuilder withArgs(List<String> args) {
      this.arguments.args = args;
      return this;
    }

    public WithDefaultArgsArguments build() {
      return this.arguments;
    }
  }

  public static class WithDirectoryArguments {
    List<String> exclude;

    List<String> include;

    String owner;

    private WithDirectoryArguments() {
    }

    static WithDirectoryArgumentsBuilder newBuilder() {
      WithDirectoryArguments args = new WithDirectoryArguments();
      return new WithDirectoryArgumentsBuilder(args);
    }

    public List<String> getExclude() {
      return this.exclude;
    }

    public List<String> getInclude() {
      return this.include;
    }

    public String getOwner() {
      return this.owner;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("exclude", this.exclude);
      builder.add("include", this.include);
      builder.add("owner", this.owner);
          return builder.build();
    }
  }

  public static class WithDirectoryArgumentsBuilder {
    private WithDirectoryArguments arguments;

    WithDirectoryArgumentsBuilder(WithDirectoryArguments arguments) {
      this.arguments = arguments;
    }

    public WithDirectoryArgumentsBuilder withExclude(List<String> exclude) {
      this.arguments.exclude = exclude;
      return this;
    }

    public WithDirectoryArgumentsBuilder withInclude(List<String> include) {
      this.arguments.include = include;
      return this;
    }

    public WithDirectoryArgumentsBuilder withOwner(String owner) {
      this.arguments.owner = owner;
      return this;
    }

    public WithDirectoryArguments build() {
      return this.arguments;
    }
  }

  public static class WithExecArguments {
    Boolean skipEntrypoint;

    String stdin;

    String redirectStdout;

    String redirectStderr;

    Boolean experimentalPrivilegedNesting;

    Boolean insecureRootCapabilities;

    private WithExecArguments() {
    }

    static WithExecArgumentsBuilder newBuilder() {
      WithExecArguments args = new WithExecArguments();
      return new WithExecArgumentsBuilder(args);
    }

    public Boolean getSkipEntrypoint() {
      return this.skipEntrypoint;
    }

    public String getStdin() {
      return this.stdin;
    }

    public String getRedirectStdout() {
      return this.redirectStdout;
    }

    public String getRedirectStderr() {
      return this.redirectStderr;
    }

    public Boolean getExperimentalPrivilegedNesting() {
      return this.experimentalPrivilegedNesting;
    }

    public Boolean getInsecureRootCapabilities() {
      return this.insecureRootCapabilities;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("skipEntrypoint", this.skipEntrypoint);
      builder.add("stdin", this.stdin);
      builder.add("redirectStdout", this.redirectStdout);
      builder.add("redirectStderr", this.redirectStderr);
      builder.add("experimentalPrivilegedNesting", this.experimentalPrivilegedNesting);
      builder.add("insecureRootCapabilities", this.insecureRootCapabilities);
          return builder.build();
    }
  }

  public static class WithExecArgumentsBuilder {
    private WithExecArguments arguments;

    WithExecArgumentsBuilder(WithExecArguments arguments) {
      this.arguments = arguments;
    }

    public WithExecArgumentsBuilder withSkipEntrypoint(Boolean skipEntrypoint) {
      this.arguments.skipEntrypoint = skipEntrypoint;
      return this;
    }

    public WithExecArgumentsBuilder withStdin(String stdin) {
      this.arguments.stdin = stdin;
      return this;
    }

    public WithExecArgumentsBuilder withRedirectStdout(String redirectStdout) {
      this.arguments.redirectStdout = redirectStdout;
      return this;
    }

    public WithExecArgumentsBuilder withRedirectStderr(String redirectStderr) {
      this.arguments.redirectStderr = redirectStderr;
      return this;
    }

    public WithExecArgumentsBuilder withExperimentalPrivilegedNesting(
        Boolean experimentalPrivilegedNesting) {
      this.arguments.experimentalPrivilegedNesting = experimentalPrivilegedNesting;
      return this;
    }

    public WithExecArgumentsBuilder withInsecureRootCapabilities(Boolean insecureRootCapabilities) {
      this.arguments.insecureRootCapabilities = insecureRootCapabilities;
      return this;
    }

    public WithExecArguments build() {
      return this.arguments;
    }
  }

  public static class WithExposedPortArguments {
    NetworkProtocol protocol;

    String description;

    private WithExposedPortArguments() {
    }

    static WithExposedPortArgumentsBuilder newBuilder() {
      WithExposedPortArguments args = new WithExposedPortArguments();
      return new WithExposedPortArgumentsBuilder(args);
    }

    public NetworkProtocol getProtocol() {
      return this.protocol;
    }

    public String getDescription() {
      return this.description;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("protocol", this.protocol);
      builder.add("description", this.description);
          return builder.build();
    }
  }

  public static class WithExposedPortArgumentsBuilder {
    private WithExposedPortArguments arguments;

    WithExposedPortArgumentsBuilder(WithExposedPortArguments arguments) {
      this.arguments = arguments;
    }

    public WithExposedPortArgumentsBuilder withProtocol(NetworkProtocol protocol) {
      this.arguments.protocol = protocol;
      return this;
    }

    public WithExposedPortArgumentsBuilder withDescription(String description) {
      this.arguments.description = description;
      return this;
    }

    public WithExposedPortArguments build() {
      return this.arguments;
    }
  }

  public static class WithFileArguments {
    Integer permissions;

    String owner;

    private WithFileArguments() {
    }

    static WithFileArgumentsBuilder newBuilder() {
      WithFileArguments args = new WithFileArguments();
      return new WithFileArgumentsBuilder(args);
    }

    public Integer getPermissions() {
      return this.permissions;
    }

    public String getOwner() {
      return this.owner;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("permissions", this.permissions);
      builder.add("owner", this.owner);
          return builder.build();
    }
  }

  public static class WithFileArgumentsBuilder {
    private WithFileArguments arguments;

    WithFileArgumentsBuilder(WithFileArguments arguments) {
      this.arguments = arguments;
    }

    public WithFileArgumentsBuilder withPermissions(Integer permissions) {
      this.arguments.permissions = permissions;
      return this;
    }

    public WithFileArgumentsBuilder withOwner(String owner) {
      this.arguments.owner = owner;
      return this;
    }

    public WithFileArguments build() {
      return this.arguments;
    }
  }

  public static class WithMountedCacheArguments {
    Directory source;

    CacheSharingMode sharing;

    String owner;

    private WithMountedCacheArguments() {
    }

    static WithMountedCacheArgumentsBuilder newBuilder() {
      WithMountedCacheArguments args = new WithMountedCacheArguments();
      return new WithMountedCacheArgumentsBuilder(args);
    }

    public Directory getSource() {
      return this.source;
    }

    public CacheSharingMode getSharing() {
      return this.sharing;
    }

    public String getOwner() {
      return this.owner;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("source", this.source);
      builder.add("sharing", this.sharing);
      builder.add("owner", this.owner);
          return builder.build();
    }
  }

  public static class WithMountedCacheArgumentsBuilder {
    private WithMountedCacheArguments arguments;

    WithMountedCacheArgumentsBuilder(WithMountedCacheArguments arguments) {
      this.arguments = arguments;
    }

    public WithMountedCacheArgumentsBuilder withSource(Directory source) {
      this.arguments.source = source;
      return this;
    }

    public WithMountedCacheArgumentsBuilder withSharing(CacheSharingMode sharing) {
      this.arguments.sharing = sharing;
      return this;
    }

    public WithMountedCacheArgumentsBuilder withOwner(String owner) {
      this.arguments.owner = owner;
      return this;
    }

    public WithMountedCacheArguments build() {
      return this.arguments;
    }
  }

  public static class WithMountedDirectoryArguments {
    String owner;

    private WithMountedDirectoryArguments() {
    }

    static WithMountedDirectoryArgumentsBuilder newBuilder() {
      WithMountedDirectoryArguments args = new WithMountedDirectoryArguments();
      return new WithMountedDirectoryArgumentsBuilder(args);
    }

    public String getOwner() {
      return this.owner;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("owner", this.owner);
          return builder.build();
    }
  }

  public static class WithMountedDirectoryArgumentsBuilder {
    private WithMountedDirectoryArguments arguments;

    WithMountedDirectoryArgumentsBuilder(WithMountedDirectoryArguments arguments) {
      this.arguments = arguments;
    }

    public WithMountedDirectoryArgumentsBuilder withOwner(String owner) {
      this.arguments.owner = owner;
      return this;
    }

    public WithMountedDirectoryArguments build() {
      return this.arguments;
    }
  }

  public static class WithMountedFileArguments {
    String owner;

    private WithMountedFileArguments() {
    }

    static WithMountedFileArgumentsBuilder newBuilder() {
      WithMountedFileArguments args = new WithMountedFileArguments();
      return new WithMountedFileArgumentsBuilder(args);
    }

    public String getOwner() {
      return this.owner;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("owner", this.owner);
          return builder.build();
    }
  }

  public static class WithMountedFileArgumentsBuilder {
    private WithMountedFileArguments arguments;

    WithMountedFileArgumentsBuilder(WithMountedFileArguments arguments) {
      this.arguments = arguments;
    }

    public WithMountedFileArgumentsBuilder withOwner(String owner) {
      this.arguments.owner = owner;
      return this;
    }

    public WithMountedFileArguments build() {
      return this.arguments;
    }
  }

  public static class WithMountedSecretArguments {
    String owner;

    private WithMountedSecretArguments() {
    }

    static WithMountedSecretArgumentsBuilder newBuilder() {
      WithMountedSecretArguments args = new WithMountedSecretArguments();
      return new WithMountedSecretArgumentsBuilder(args);
    }

    public String getOwner() {
      return this.owner;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("owner", this.owner);
          return builder.build();
    }
  }

  public static class WithMountedSecretArgumentsBuilder {
    private WithMountedSecretArguments arguments;

    WithMountedSecretArgumentsBuilder(WithMountedSecretArguments arguments) {
      this.arguments = arguments;
    }

    public WithMountedSecretArgumentsBuilder withOwner(String owner) {
      this.arguments.owner = owner;
      return this;
    }

    public WithMountedSecretArguments build() {
      return this.arguments;
    }
  }

  public static class WithNewFileArguments {
    String contents;

    Integer permissions;

    String owner;

    private WithNewFileArguments() {
    }

    static WithNewFileArgumentsBuilder newBuilder() {
      WithNewFileArguments args = new WithNewFileArguments();
      return new WithNewFileArgumentsBuilder(args);
    }

    public String getContents() {
      return this.contents;
    }

    public Integer getPermissions() {
      return this.permissions;
    }

    public String getOwner() {
      return this.owner;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("contents", this.contents);
      builder.add("permissions", this.permissions);
      builder.add("owner", this.owner);
          return builder.build();
    }
  }

  public static class WithNewFileArgumentsBuilder {
    private WithNewFileArguments arguments;

    WithNewFileArgumentsBuilder(WithNewFileArguments arguments) {
      this.arguments = arguments;
    }

    public WithNewFileArgumentsBuilder withContents(String contents) {
      this.arguments.contents = contents;
      return this;
    }

    public WithNewFileArgumentsBuilder withPermissions(Integer permissions) {
      this.arguments.permissions = permissions;
      return this;
    }

    public WithNewFileArgumentsBuilder withOwner(String owner) {
      this.arguments.owner = owner;
      return this;
    }

    public WithNewFileArguments build() {
      return this.arguments;
    }
  }

  public static class WithUnixSocketArguments {
    String owner;

    private WithUnixSocketArguments() {
    }

    static WithUnixSocketArgumentsBuilder newBuilder() {
      WithUnixSocketArguments args = new WithUnixSocketArguments();
      return new WithUnixSocketArgumentsBuilder(args);
    }

    public String getOwner() {
      return this.owner;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("owner", this.owner);
          return builder.build();
    }
  }

  public static class WithUnixSocketArgumentsBuilder {
    private WithUnixSocketArguments arguments;

    WithUnixSocketArgumentsBuilder(WithUnixSocketArguments arguments) {
      this.arguments = arguments;
    }

    public WithUnixSocketArgumentsBuilder withOwner(String owner) {
      this.arguments.owner = owner;
      return this;
    }

    public WithUnixSocketArguments build() {
      return this.arguments;
    }
  }

  public static class WithoutExposedPortArguments {
    NetworkProtocol protocol;

    private WithoutExposedPortArguments() {
    }

    static WithoutExposedPortArgumentsBuilder newBuilder() {
      WithoutExposedPortArguments args = new WithoutExposedPortArguments();
      return new WithoutExposedPortArgumentsBuilder(args);
    }

    public NetworkProtocol getProtocol() {
      return this.protocol;
    }

    public Arguments toArguments() {
      Arguments.Builder builder = Arguments.newBuilder();
      builder.add("protocol", this.protocol);
          return builder.build();
    }
  }

  public static class WithoutExposedPortArgumentsBuilder {
    private WithoutExposedPortArguments arguments;

    WithoutExposedPortArgumentsBuilder(WithoutExposedPortArguments arguments) {
      this.arguments = arguments;
    }

    public WithoutExposedPortArgumentsBuilder withProtocol(NetworkProtocol protocol) {
      this.arguments.protocol = protocol;
      return this;
    }

    public WithoutExposedPortArguments build() {
      return this.arguments;
    }
  }
}
